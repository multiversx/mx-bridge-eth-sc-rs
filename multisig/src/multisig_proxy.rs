// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct MultisigProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for MultisigProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = MultisigProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        MultisigProxyMethods { wrapped_tx: tx }
    }
}

pub struct MultisigProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> MultisigProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// EsdtSafe and MultiTransferEsdt are expected to be deployed and configured separately, 
    /// and then having their ownership changed to this Multisig SC. 
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<usize>,
        Arg6: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        esdt_safe_sc_address: Arg0,
        multi_transfer_sc_address: Arg1,
        proxy_sc_address: Arg2,
        required_stake: Arg3,
        slash_amount: Arg4,
        quorum: Arg5,
        board: Arg6,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&esdt_safe_sc_address)
            .argument(&multi_transfer_sc_address)
            .argument(&proxy_sc_address)
            .argument(&required_stake)
            .argument(&slash_amount)
            .argument(&quorum)
            .argument(&board)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> MultisigProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        esdt_safe_sc_address: Arg0,
        multi_transfer_sc_address: Arg1,
        proxy_sc_address: Arg2,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .argument(&esdt_safe_sc_address)
            .argument(&multi_transfer_sc_address)
            .argument(&proxy_sc_address)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> MultisigProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Board members have to stake a certain amount of EGLD 
    /// before being allowed to sign actions 
    pub fn stake(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stake")
            .original_result()
    }

    /// After a batch is processed on the Ethereum side, 
    /// the EsdtSafe expects a list of statuses of said transactions (success or failure). 
    ///  
    /// This endpoint proposes an action to set the statuses to a certain list of values. 
    /// Nothing is changed in the EsdtSafe contract until the action is signed and executed. 
    pub fn propose_esdt_safe_set_current_transaction_batch_status<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, transaction::transaction_status::TransactionStatus>>,
    >(
        self,
        esdt_safe_batch_id: Arg0,
        tx_batch_status: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("proposeEsdtSafeSetCurrentTransactionBatchStatus")
            .argument(&esdt_safe_batch_id)
            .argument(&tx_batch_status)
            .original_result()
    }

    /// Proposes a batch of Ethereum -> MultiversX transfers. 
    /// Transactions have to be separated by fields, in the following order: 
    /// Sender Address, Destination Address, Token ID, Amount, Tx Nonce 
    pub fn propose_multi_transfer_esdt_batch<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, MultiValue6<eth_address::EthAddress<Env::Api>, ManagedAddress<Env::Api>, TokenIdentifier<Env::Api>, BigUint<Env::Api>, u64, Option<ManagedBuffer<Env::Api>>>>>,
    >(
        self,
        eth_batch_id: Arg0,
        transfers: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("proposeMultiTransferEsdtBatch")
            .argument(&eth_batch_id)
            .argument(&transfers)
            .original_result()
    }

    /// Failed Ethereum -> MultiversX transactions are saved in the MultiTransfer SC 
    /// as "refund transactions", and stored in batches, using the same mechanism as EsdtSafe. 
    ///  
    /// This function moves the first refund batch into the EsdtSafe SC, 
    /// converting the transactions into MultiversX -> Ethereum transactions 
    /// and adding them into EsdtSafe batches 
    pub fn move_refund_batch_to_safe_from_child_contract(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("moveRefundBatchToSafeFromChildContract")
            .original_result()
    }

    /// Proposers and board members use this to launch signed actions. 
    pub fn perform_action_endpoint<
        Arg0: ProxyArg<usize>,
    >(
        self,
        action_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("performAction")
            .argument(&action_id)
            .original_result()
    }

    /// Used by board members to sign actions. 
    pub fn sign<
        Arg0: ProxyArg<usize>,
    >(
        self,
        action_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sign")
            .argument(&action_id)
            .original_result()
    }

    /// Returns a batch of failed Ethereum -> MultiversX transactions. 
    /// The result format is the same as getCurrentTxBatch 
    pub fn get_current_refund_batch(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<MultiValue2<u64, MultiValueEncoded<Env::Api, MultiValue6<u64, u64, ManagedBuffer<Env::Api>, ManagedBuffer<Env::Api>, TokenIdentifier<Env::Api>, BigUint<Env::Api>>>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentRefundBatch")
            .original_result()
    }

    /// Used for Ethereum -> MultiversX batches. 
    /// If the mapping was made, it means that the transfer action was proposed in the past. 
    /// To check if it was executed as well, use the wasActionExecuted view 
    pub fn was_transfer_action_proposed<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, MultiValue6<eth_address::EthAddress<Env::Api>, ManagedAddress<Env::Api>, TokenIdentifier<Env::Api>, BigUint<Env::Api>, u64, Option<ManagedBuffer<Env::Api>>>>>,
    >(
        self,
        eth_batch_id: Arg0,
        transfers: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("wasTransferActionProposed")
            .argument(&eth_batch_id)
            .argument(&transfers)
            .original_result()
    }

    /// Used for Ethereum -> MultiversX batches. 
    /// If `wasActionExecuted` returns true, then this can be used to get the action ID. 
    /// Will return 0 if the transfers were not proposed 
    pub fn get_action_id_for_transfer_batch<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, MultiValue6<eth_address::EthAddress<Env::Api>, ManagedAddress<Env::Api>, TokenIdentifier<Env::Api>, BigUint<Env::Api>, u64, Option<ManagedBuffer<Env::Api>>>>>,
    >(
        self,
        eth_batch_id: Arg0,
        transfers: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getActionIdForTransferBatch")
            .argument(&eth_batch_id)
            .argument(&transfers)
            .original_result()
    }

    /// Lists all board members that staked the correct amount. 
    /// A board member with not enough stake can propose, but cannot sign. 
    pub fn get_all_staked_relayers(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllStakedRelayers")
            .original_result()
    }

    pub fn unpause_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpause")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, Clone, Copy, PartialEq)]
pub enum UserRole {
    None,
    BoardMember,
}

#[rustfmt::skip]
#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub enum Action<Api>
where
    Api: ManagedTypeApi,
{
    Nothing,
    SetCurrentTransactionBatchStatus {
        esdt_safe_batch_id: u64,
        tx_batch_status: ManagedVec<Api, transaction::transaction_status::TransactionStatus>,
    },
    BatchTransferEsdtToken {
        eth_batch_id: u64,
        transfers: ManagedVec<Api, transaction::EthTransaction<Api>>,
    },
}
